default_platform :ios

platform :ios do

######################
# Pre-defined values #
######################

# The output folder for test coverage data
test_output_folder = 'test_output'

# The root fastlane folder
fastlane_folder='fastlane'

# The URL for the slack webhook to post to
slack_webhook_url='https://hooks.slack.com/services/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'

# The username of the CI user on iTunes Connect.
ci_username = 'ci-ios@spothero.com'

# Files to ignore in code coverage, as an array of strings. Wildcards may be used.
coverage_files_to_ignore = [
    'Pods/*',
]

# The location where derived data should be placed.
derived_data_folder = File.join(fastlane_folder, "DerivedData")

#########################
# Per-Project Variables #
#########################

# The name of the main scheme for building and testing the app. Must be a shared scheme!
main_scheme = 'SpotHero_iOS_Partner_SDK-Example'

# The path to the .xcworkspace file
workspace_file='Example/SpotHero_iOS_Partner_SDK.xcworkspace'

# The path to the .xcodeproj for the framework (for getting coverage info)
project_file='Example/SpotHero_iOS_Partner_SDK.xcodeproj'

# The name of the keychain to use on CI
keychain_name = 'SpotHeroSDKKeys.keychain'

# The path to the Certificates.p12 file which should be used to sign the app
p12_file = 'Certificates/SpotHeroiOSReleaseCertificates.p12'

# The identifier to use for testflight uploads
test_flight_app_identifier = 'com.spothero.demo.SpotHero-iOS-Partner-SDK-Example'

# The name on the signing certificate for distribution
codesigning_id = 'iPhone Distribution: Spot Hero Inc.'

# The identifier of the team to use when retrieving provisioning profiles
team_identifier = 'ZW7QWR628D'

# The name of the TestFlight provisioning profile
test_flight_provisioning_profile_name = 'Distribution App Store: SDK Sample App'

#########################
# Pod Project Variables #
#########################

###########
## SETUP ##
###########

    before_all do
        ENV['SLACK_URL'] = slack_webhook_url

        if is_ci
            # Make sure we're on Xcode 7 on the build server.
            switch_to_xcode_7
        end
    end

##############
## KEYCHAIN ##
##############

    private_lane :setup_keychain do
        puts "------ Creating Keychain -------"

        cert_password = ENV["P12_PASSWORD"]
        if cert_password == "FIXME"
            raise 'You need to update your P12_PASSWORD on Jenkins and/or local_config.sh'
        end

        begin
            # Create a keychain in which to store the signing cert.
            create_keychain(
               default_keychain: false,
               name: keychain_name,
               unlock: true,
               timeout: 3600,
               password: cert_password,
            )
        rescue
            # Prevent crashage if there's already a keychain
            puts "Keychain already set up!"
        end

        puts "------ Importing Cert ------"

        # Import Ye Cert to that keychain
        import_certificate(
            keychain_name: keychain_name,
            certificate_path: File.join(fastlane_folder, p12_file),
            certificate_password: cert_password,
        )
    end

    private_lane :teardown_keychain do
        begin
            # Nuke the keychain:
            delete_keychain(
                name: keychain_name
            )
        rescue
            # Prevent crashage if there's no keychain
            puts "Keychain already deleted!"
        end
    end


#############################
## TESTING & CODE COVERAGE ##
#############################

    def switch_to_xcode_7
        xcversion(
            version: "7.3.1",
        )
    end

    def switch_to_xcode_8
        xcversion(
            version: "~> 8.1.0", # Selects the latest installed version from the 8.1.x set
        )
    end

    desc "Runs tests with the given options"
    desc "Expects values for the following keys:"
    desc "scheme_options_key: The name of the scheme to use to run the tests"
    desc "output_options_key: The path to output information from the tests"
    desc "workspace_options_key: The path to the workspace to run tests on"
    private_lane :run_tests do |options|
        if !options.key?(:scheme_options_key) || !options.key?(:output_options_key) || !options.key?(:workspace_options_key)
            raise "Not all required options for this lane are present!"
            return
        end

        #stop any existing sims
        sh "./kill_sim_if_running.sh"

        workspace = options[:workspace_options_key]
        scheme = options[:scheme_options_key]
        output_folder = options[:output_options_key]

        # Build and run the given tests
        scan(
            workspace: workspace,
            scheme: scheme,
            skip_slack: !is_ci, # only let us know if we're on CI
            output_directory: File.join(fastlane_folder, output_folder),
            derived_data_path: derived_data_folder,
            clean: true,
            skip_build: true, #the test action will already kick off a build, don't build twice
        )
    end

    desc "Runs all the tests of the sample app"
    lane :test do
        run_tests(
            scheme_options_key: main_scheme,
            output_options_key: test_output_folder,
            workspace_options_key: workspace_file,
        )
    end

    desc "Runs all the tests of the app and gathers code coverage across all versions of xcode"
    lane :test_all do
        switch_to_xcode_7
        test
        switch_to_xcode_8
        test
    end

########################
## BUILDING & SIGNING ##
########################

    desc "Uses sigh to go out and get the specified provisioning profile"
    desc "Expects values for the following keys:"
    desc "profile_options_key: The name of the profile to retrieve"
    desc "app_identifier_options_key: The name of the app identifier to use"
    private_lane :get_provisioning do |options|
        if !options.key?(:profile_options_key) || !options.key?(:app_identifier_options_key)
            raise "Not all required options for this lane are present!"
            return
        end

        # Get the provisioning profile to use
        provisioning = options[:profile_options_key]

        # Get the app identifier to use
        identifier = options[:app_identifier_options_key]

        if ENV["FASTLANE_PASSWORD"] == "FIXME"
            raise "You need to set up your FASTLANE_PASSWORD in Jenkins, local_config.sh, or both!"
            return
        end

        # Get current version of specified provisioning profile
        sigh(
            adhoc: false,
            app_identifier: identifier,
            username: ci_username,
            team_id: team_identifier,
            output_path: File.join(fastlane_folder, "Provisioning"),
            provisioning_name: provisioning,
        )
    end

    desc "Uses gym to output a build with the specified options."
    desc "Expects values for the following keys:"
    desc "method_options_key: Specify method for building: 'ad-hoc' or 'app-store'"
    desc "scheme_options_key: The scheme to use for building"
    private_lane :archive_build do |options|
        if !options.key?(:method_options_key) || !options.key?(:scheme_options_key)
            raise "Not all required options for this lane are present!"
            return
        end

        method = options[:method_options_key]
        scheme = options[:scheme_options_key]

        # make sure the build folder actually exists first
        build_folder_name = "Build"
        sh("mkdir -p #{build_folder_name}")

        # Archive away!
        gym(
            workspace: workspace_file,
            scheme: scheme,
            export_method: method,
            output_directory:  File.join(fastlane_folder, build_folder_name),
            derived_data_path: derived_data_folder,
            include_bitcode: false,
            include_symbols: true,
            clean: true,
            codesigning_identity: codesigning_id,
        )
    end

    desc "Responsible for building and signing the app for Test Flight distribution"
    desc "Note: This will always create a build pointed at Production."
    desc "Note: Setup/teardown of the keychain should be handled outside this method."
    private_lane :build_itc do
        # Make sure the App Store provisioning profile name is actually set up
        if test_flight_provisioning_profile_name == "FIXME"
            raise "You need to set up the TestFlight provisioning profile name at the top of your Fastfile!"
            return
        end

        setup_keychain

        # Get current version of TestFlight profile
        get_provisioning(
          profile_options_key: test_flight_provisioning_profile_name,
          app_identifier_options_key: test_flight_app_identifier
        )

        puts "------ BUILDING TESTFLIGHT/ITC FOR SDK SAMPLE APP -------"

        # Build Production-pointed app for App Store / Test Flight
        archive_build(
            scheme_options_key: main_scheme,
            method_options_key: 'app-store',
        )
    end


##################
## DISTRIBUTION ##
##################

    desc "Uploads a build iTunes Connect"
    desc "Note: This build should only be distributed via Test Flight."
    private_lane :itc do
        #Build with latest Xcode
        switch_to_xcode_8

        # Create an iTunes Connect build
        build_itc

        # Upload build to ITC
        pilot(
            username: ci_username,
            changelog: "This build was automatically uploaded by Fastlane - DO NOT SUBMIT FOR TEST FLIGHT UNTIL RELEASE NOTES ARE UPDATED!!!!",
            distribute_external: false,
            skip_submission: true,
            app_identifier: test_flight_app_identifier,
            skip_waiting_for_build_processing: true,
        )

        slack(message: "SDK Sample app build uploaded to iTunes Connect!", success: true)
    end

    def calculate_current_version
        version = sh("git describe --tags $(git rev-list --tags='b[0-9]*' --max-count=1) --abbrev=0")

        puts("#{version}")

        #trim off the b
        trimmed_version = version[1..version.length]
        puts("#{trimmed_version}")

        #make it an integer
        integer_version = trimmed_version.to_i
        current_version = integer_version + 1
        return current_version
    end

    def checkout_current_branch
        # For some reason, Jenkins is checking out a detached HEAD instead of the appropriate branch.
        current_branch = ENV["GIT_BRANCH"]
        if current_branch
            # Split on the first slash to trim the remote name off the branch name
            split_on_first_slash = current_branch.split("/", 2)
            current_branch = split_on_first_slash[1]
        elsif
            # We're not getting it from the environment - grab it from git by finding the starred branch.
            current_branch = sh("git branch | grep \\*")

            # Trim off the "* " bit (2 characters)
            current_branch = current_branch[2..current_branch.length]
        end

        # Check out the appropriate branch
        sh "git checkout " + current_branch
    end

    desc "Bumps the version, commits it to git with the appropriate tag, and pushes to the remote."
    lane :bump_commit do
        checkout_current_branch

        #figure out what the latest build number is
        current_version = calculate_current_version
        puts("Current version: #{current_version.to_s}")

        # Update the build number and commit it
        increment_build_number(
            build_number: current_version,
            xcodeproj: project_file,
        )
        commit_version_bump(
            xcodeproj: project_file,
        )

        # Set the tag as b(build number) for the committed version bump.
        build_number = Actions.lane_context[Actions::SharedValues::BUILD_NUMBER]
        add_git_tag(
            tag: "b" + build_number
        )
    end

    desc "Method which pushes commits using SSH instead of stored creds"
    private_lane :push_with_ssh do
        # Update the remote URL for origin to use ssh
        sh "git remote set-url origin git@github.com:spothero/iOS-Partner-SDK.git"

        # Push to remote with tags using ssh
        push_to_git_remote(
            tags: true,
        )
    end

    desc "Method to run after a successful merge."
    desc "Will bump/commit/tag/push the version and upload to iTunes Connect."
    lane :sample_itc do
        bump_commit
        itc
        push_with_ssh
    end


######################
## SUCCESS HANDLING ##
######################

    # This gets called if the executed lanes were all successful
    after_all do |lane|
        puts "Success!"

        if is_ci
            slack(message: "iOS App build succeeded", success: true)
        end

        # Tear down the keychain now that it's built and signed so nobody else can use it.
        teardown_keychain
    end


######################
## FAILURE HANDLING ##
######################

    # This gets called if anything failed along the way
    error do |lane, exception|
        puts "---- SOMETHING FAILED ---"
        if is_ci
            slack(message: "iOS App build FAIL!!!!: #{exception}", success: false)
        end

        # Nuke the keychain:
        teardown_keychain
    end
end
